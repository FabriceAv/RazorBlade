// <auto-generated />

using System.Globalization;

namespace Microsoft.AspNetCore.Razor.Language;

#if !RAZOR_EXTERNAL_LIB

internal static class ComponentResources
{
    internal static string AttributeDirective_AttributeToken_Description
        => @"The C# attribute that will be applied to the current class.";

    internal static string AttributeDirective_AttributeToken_Name
        => @"Attribute";

    internal static string AttributeDirective_Description
        => @"Specifies the C# attribute that will be applied to the current class.";

    internal static string BindTagHelper_Component_Documentation
        => @"Binds the provided expression to the '{0}' property and a change event delegate to the '{1}' property of the component.";

    internal static string FormatBindTagHelper_Component_Documentation(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, BindTagHelper_Component_Documentation, p0, p1);

    internal static string BindTagHelper_Element_After_Documentation
        => @"Specifies an action to run after the new value has been set.";

    internal static string BindTagHelper_Element_Culture_Documentation
        => @"Specifies the culture to use for conversions.";

    internal static string BindTagHelper_Element_Documentation
        => @"Binds the provided expression to the '{0}' attribute and a change event delegate to the '{1}' attribute.";

    internal static string FormatBindTagHelper_Element_Documentation(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, BindTagHelper_Element_Documentation, p0, p1);

    internal static string BindTagHelper_Element_Event_Documentation
        => @"Specifies the event handler name to attach for change notifications for the value provided by the '{0}' attribute.";

    internal static string FormatBindTagHelper_Element_Event_Documentation(object p0)
        => string.Format(CultureInfo.InvariantCulture, BindTagHelper_Element_Event_Documentation, p0);

    internal static string BindTagHelper_Element_Format_Documentation
        => @"Specifies a format to convert the value specified by the '{0}' attribute. The format string can currently only be used with expressions of type <code>DateTime</code>.";

    internal static string FormatBindTagHelper_Element_Format_Documentation(object p0)
        => string.Format(CultureInfo.InvariantCulture, BindTagHelper_Element_Format_Documentation, p0);

    internal static string BindTagHelper_Element_Get_Documentation
        => @"Specifies the expression to use for binding the value to the attribute.";

    internal static string BindTagHelper_Element_Set_Documentation
        => @"Specifies the expression to use for updating the bound value when a new value is available.";

    internal static string BindTagHelper_Fallback_Documentation
        => @"Binds the provided expression to an attribute and a change event, based on the naming of the bind attribute. For example: <code>@bind-value=""...""</code> and <code>@bind-value:event=""onchange""</code> will assign the current value of the expression to the 'value' attribute, and assign a delegate that attempts to set the value to the 'onchange' attribute.";

    internal static string BindTagHelper_Fallback_Event_Documentation
        => @"Specifies the event handler name to attach for change notifications for the value provided by the '{0}' attribute.";

    internal static string FormatBindTagHelper_Fallback_Event_Documentation(object p0)
        => string.Format(CultureInfo.InvariantCulture, BindTagHelper_Fallback_Event_Documentation, p0);

    internal static string BindTagHelper_Fallback_Format_Documentation
        => @"Specifies a format to convert the value specified by the corresponding bind attribute. For example: <code>@bind-value:format=""...""</code> will apply a format string to the value specified in <code>@bind-value=""...""</code>. The format string can currently only be used with expressions of type <code>DateTime</code>.";

    internal static string ChildContentParameterName_Documentation
        => @"Specifies the parameter name for the '{0}' child content expression.";

    internal static string FormatChildContentParameterName_Documentation(object p0)
        => string.Format(CultureInfo.InvariantCulture, ChildContentParameterName_Documentation, p0);

    internal static string ChildContentParameterName_TopLevelDocumentation
        => @"Specifies the parameter name for all child content expressions.";

    internal static string ComponentTypeParameter_Documentation
        => @"Specifies the type of the type parameter {0} for the {1} component.";

    internal static string FormatComponentTypeParameter_Documentation(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, ComponentTypeParameter_Documentation, p0, p1);

    internal static string EventHandlerTagHelper_Documentation
        => @"Sets the '{0}' attribute to the provided string or delegate value. A delegate value should be of type '{1}'.";

    internal static string FormatEventHandlerTagHelper_Documentation(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, EventHandlerTagHelper_Documentation, p0, p1);

    internal static string EventHandlerTagHelper_PreventDefault_Documentation
        => @"Specifies whether to cancel (if cancelable) the default action that belongs to the '{0}' event.";

    internal static string FormatEventHandlerTagHelper_PreventDefault_Documentation(object p0)
        => string.Format(CultureInfo.InvariantCulture, EventHandlerTagHelper_PreventDefault_Documentation, p0);

    internal static string EventHandlerTagHelper_StopPropagation_Documentation
        => @"Specifies whether to prevent further propagation of the '{0}' event in the capturing and bubbling phases.";

    internal static string FormatEventHandlerTagHelper_StopPropagation_Documentation(object p0)
        => string.Format(CultureInfo.InvariantCulture, EventHandlerTagHelper_StopPropagation_Documentation, p0);

    internal static string ImplementsDirective_Description
        => @"Declares an interface implementation for the current class.";

    internal static string ImplementsDirective_TypeToken_Description
        => @"The interface type implemented by the current class.";

    internal static string ImplementsDirective_TypeToken_Name
        => @"TypeName";

    internal static string KeyTagHelper_Documentation
        => @"Ensures that the component or element will be preserved across renders if (and only if) the supplied key value matches.";

    internal static string LayoutDirective_Description
        => @"Declares a layout type for the current document.";

    internal static string LayoutDirective_TypeToken_Description
        => @"The interface type implemented by the current document.";

    internal static string LayoutDirective_TypeToken_Name
        => @"TypeName";

    internal static string PageDirectiveCannotBeImported
        => @"The '@{0}' directive specified in {1} file will not be imported. The directive must appear at the top of each Razor file";

    internal static string FormatPageDirectiveCannotBeImported(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, PageDirectiveCannotBeImported, p0, p1);

    internal static string PageDirective_Description
        => @"Mark the page as a routable component.";

    internal static string PageDirective_RouteToken_Description
        => @"An optional route template for the component.";

    internal static string PageDirective_RouteToken_Name
        => @"route template";

    internal static string PreserveWhitespaceDirective_BooleanToken_Description
        => @"True if whitespace should be preserved, otherwise false.";

    internal static string PreserveWhitespaceDirective_BooleanToken_Name
        => @"Preserve";

    internal static string PreserveWhitespaceDirective_Description
        => @"Specifies whether or not whitespace should be preserved exactly. Defaults to false for better performance.";

    internal static string RefTagHelper_Documentation
        => @"Populates the specified field or property with a reference to the element or component.";

    internal static string SplatTagHelper_Documentation
        => @"Merges a collection of attributes into the current element or component.";

    internal static string TypeParamDirective_Constraint_Description
        => @"The constraints applied to the type parameter.";

    internal static string TypeParamDirective_Constraint_Name
        => @"type parameter constraint";

    internal static string TypeParamDirective_Description
        => @"Declares a generic type parameter for the generated component class.";

    internal static string TypeParamDirective_Token_Description
        => @"The name of the type parameter.";

    internal static string TypeParamDirective_Token_Name
        => @"type parameter";

}

internal static class Resources
{
    internal static string AddTagHelperDirective_Description
        => @"Register Tag Helpers for use in the current document.";

    internal static string AddTagHelperDirective_StringToken_Description
        => @"Add tag helpers from the specified type name and assembly name. Specify '*' for the type name to include all tag helper types from the specified assembly.";

    internal static string AddTagHelperDirective_StringToken_Name
        => @"TypeName, AssemblyName";

    internal static string ArgumentCannotBeNullOrEmpty
        => @"Value cannot be null or an empty string.";

    internal static string Block_Type_Not_Specified
        => @"Block cannot be built because a Type has not been specified in the BlockBuilder";

    internal static string BlockDirectiveCannotBeImported
        => @"Block directive '{0}' cannot be imported.";

    internal static string FormatBlockDirectiveCannotBeImported(object p0)
        => string.Format(CultureInfo.InvariantCulture, BlockDirectiveCannotBeImported, p0);

    internal static string BlockName_Code
        => @"code";

    internal static string BlockName_ExplicitExpression
        => @"explicit expression";

    internal static string CodeWriter_InvalidNewLine
        => @"Invalid newline sequence '{0}'. Support newline sequences are '\r\n' and '\n'.";

    internal static string FormatCodeWriter_InvalidNewLine(object p0)
        => string.Format(CultureInfo.InvariantCulture, CodeWriter_InvalidNewLine, p0);

    internal static string CSharpToken_CharacterLiteral
        => @"<<character literal>>";

    internal static string CSharpToken_Comment
        => @"<<comment>>";

    internal static string CSharpToken_Identifier
        => @"<<identifier>>";

    internal static string CSharpToken_IntegerLiteral
        => @"<<integer literal>>";

    internal static string CSharpToken_Keyword
        => @"<<keyword>>";

    internal static string CSharpToken_Newline
        => @"<<newline sequence>>";

    internal static string CSharpToken_RealLiteral
        => @"<<real literal>>";

    internal static string CSharpToken_StringLiteral
        => @"<<string literal>>";

    internal static string CSharpToken_Whitespace
        => @"<<white space>>";

    internal static string Diagnostic_CodeTarget_UnsupportedExtension
        => @"The document type '{0}' does not support the extension '{1}'.";

    internal static string FormatDiagnostic_CodeTarget_UnsupportedExtension(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, Diagnostic_CodeTarget_UnsupportedExtension, p0, p1);

    internal static string DirectiveDescriptor_InvalidDirectiveKeyword
        => @"Invalid directive keyword '{0}'. Directives must have a non-empty keyword that consists only of letters.";

    internal static string FormatDirectiveDescriptor_InvalidDirectiveKeyword(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveDescriptor_InvalidDirectiveKeyword, p0);

    internal static string DirectiveDescriptor_InvalidNonOptionalToken
        => @"A non-optional directive token cannot follow an optional directive token.";

    internal static string DirectiveExpectsIdentifier
        => @"The '{0}' directive expects an identifier.";

    internal static string FormatDirectiveExpectsIdentifier(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveExpectsIdentifier, p0);

    internal static string DirectiveExpectsNamespace
        => @"The '{0}' directive expects a namespace name.";

    internal static string FormatDirectiveExpectsNamespace(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveExpectsNamespace, p0);

    internal static string DirectiveExpectsQuotedStringLiteral
        => @"The '{0}' directive expects a string surrounded by double quotes.";

    internal static string FormatDirectiveExpectsQuotedStringLiteral(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveExpectsQuotedStringLiteral, p0);

    internal static string DirectiveExpectsTypeName
        => @"The '{0}' directive expects a type name.";

    internal static string FormatDirectiveExpectsTypeName(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveExpectsTypeName, p0);

    internal static string DirectiveMustAppearAtStartOfLine
        => @"The '{0}` directive must appear at the start of the line.";

    internal static string FormatDirectiveMustAppearAtStartOfLine(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveMustAppearAtStartOfLine, p0);

    internal static string DirectiveTokensMustBeSeparatedByWhitespace
        => @"The '{0}' directives value(s) must be separated by whitespace.";

    internal static string FormatDirectiveTokensMustBeSeparatedByWhitespace(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveTokensMustBeSeparatedByWhitespace, p0);

    internal static string DocumentMissingTarget
        => @"The document of kind '{0}' does not have a '{1}'. The document classifier must set a value for '{2}'.";

    internal static string FormatDocumentMissingTarget(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, DocumentMissingTarget, p0, p1, p2);

    internal static string DuplicateDirective
        => @"The '{0}' directive may only occur once per document.";

    internal static string FormatDuplicateDirective(object p0)
        => string.Format(CultureInfo.InvariantCulture, DuplicateDirective, p0);

    internal static string EndBlock_Called_Without_Matching_StartBlock
        => @"""EndBlock"" was called without a matching call to ""StartBlock"".";

    internal static string ErrorComponent_Newline
        => @"line break";

    internal static string FeatureDependencyMissing
        => @"The '{0}' feature requires a '{1}' provided by the '{2}'.";

    internal static string FormatFeatureDependencyMissing(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, FeatureDependencyMissing, p0, p1, p2);

    internal static string FeatureMustBeInitialized
        => @"The feature must be initialized by setting the '{0}' property.";

    internal static string FormatFeatureMustBeInitialized(object p0)
        => string.Format(CultureInfo.InvariantCulture, FeatureMustBeInitialized, p0);

    internal static string FunctionsDirective_Description
        => @"Specify a C# code block.";

    internal static string HtmlToken_NewLine
        => @"<<newline sequence>>";

    internal static string HtmlToken_RazorComment
        => @"<<razor comment>>";

    internal static string HtmlToken_Text
        => @"<<text>>";

    internal static string HtmlToken_WhiteSpace
        => @"<<white space>>";

    internal static string InheritsDirective_Description
        => @"Specify the base class for the current document.";

    internal static string InheritsDirective_TypeToken_Description
        => @"The base type that the current page inherits.";

    internal static string InheritsDirective_TypeToken_Name
        => @"TypeName";

    internal static string IntermediateNodeBuilder_PopInvalid
        => @"The '{0}' operation is not valid when the builder is empty.";

    internal static string FormatIntermediateNodeBuilder_PopInvalid(object p0)
        => string.Format(CultureInfo.InvariantCulture, IntermediateNodeBuilder_PopInvalid, p0);

    internal static string IntermediateNodeReference_CollectionIsReadOnly
        => @"The node '{0}' has a read-only child collection and cannot be modified.";

    internal static string FormatIntermediateNodeReference_CollectionIsReadOnly(object p0)
        => string.Format(CultureInfo.InvariantCulture, IntermediateNodeReference_CollectionIsReadOnly, p0);

    internal static string IntermediateNodeReference_NodeNotFound
        => @"The reference is invalid. The node '{0}' could not be found as a child of '{1}'.";

    internal static string FormatIntermediateNodeReference_NodeNotFound(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, IntermediateNodeReference_NodeNotFound, p0, p1);

    internal static string IntermediateNodeReference_NotInitialized
        => @"The reference is invalid. References initialized with the default constructor cannot modify nodes.";

    internal static string IntermediateNodes_InvalidParentNode
        => @"The '{0}' node type can only be used as a direct child of a '{1}' node.";

    internal static string FormatIntermediateNodes_InvalidParentNode(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, IntermediateNodes_InvalidParentNode, p0, p1);

    internal static string InvalidOperation_SpanIsNotChangeOwner
        => @"The node '{0}' is not the owner of change '{1}'.";

    internal static string FormatInvalidOperation_SpanIsNotChangeOwner(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, InvalidOperation_SpanIsNotChangeOwner, p0, p1);

    internal static string InvalidTagHelperLookupText
        => @"Invalid tag helper directive look up text '{0}'. The correct look up text format is: ""name, assemblyName"".";

    internal static string FormatInvalidTagHelperLookupText(object p0)
        => string.Format(CultureInfo.InvariantCulture, InvalidTagHelperLookupText, p0);

    internal static string InvalidTagHelperPrefixValue
        => @"Invalid tag helper directive '{0}' value. '{1}' is not allowed in prefix '{2}'.";

    internal static string FormatInvalidTagHelperPrefixValue(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, InvalidTagHelperPrefixValue, p0, p1, p2);

    internal static string KeyMustNotBeNull
        => @"The key must not be null.";

    internal static string Language_Does_Not_Support_RazorComment
        => @"Cannot use built-in RazorComment handler, language characteristics does not define the CommentStart, CommentStar and CommentBody known token types or parser does not override TokenizerBackedParser.OutputSpanBeforeRazorComment";

    internal static string MismatchedContentEncoding
        => @"The specified encoding '{0}' does not match the content's encoding '{1}'.";

    internal static string FormatMismatchedContentEncoding(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, MismatchedContentEncoding, p0, p1);

    internal static string ParseError_AtInCode_Must_Be_Followed_By_Colon_Paren_Or_Identifier_Start
        => @"The ""@"" character must be followed by a "":"", ""("", or a C# identifier.  If you intended to switch to markup, use an HTML start tag, for example:

@if(isLoggedIn) {{
    <p>Hello, @user!</p>
}}";

    internal static string ParseError_BlockComment_Not_Terminated
        => @"End of file was reached before the end of the block comment.  All comments started with ""/*"" sequence must be terminated with a matching ""*/"" sequence.";

    internal static string ParseError_DirectiveMustHaveValue
        => @"Directive '{0}' must have a value.";

    internal static string FormatParseError_DirectiveMustHaveValue(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_DirectiveMustHaveValue, p0);

    internal static string ParseError_Expected_CloseBracket_Before_EOF
        => @"An opening ""{0}"" is missing the corresponding closing ""{1}"".";

    internal static string FormatParseError_Expected_CloseBracket_Before_EOF(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, ParseError_Expected_CloseBracket_Before_EOF, p0, p1);

    internal static string ParseError_Expected_EndOfBlock_Before_EOF
        => @"The {0} block is missing a closing ""{1}"" character.  Make sure you have a matching ""{1}"" character for all the ""{2}"" characters within this block, and that none of the ""{1}"" characters are being interpreted as markup.";

    internal static string FormatParseError_Expected_EndOfBlock_Before_EOF(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, ParseError_Expected_EndOfBlock_Before_EOF, p0, p1, p2);

    internal static string ParseError_HelperDirectiveNotAvailable
        => @"The {0} directive is not supported.";

    internal static string FormatParseError_HelperDirectiveNotAvailable(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_HelperDirectiveNotAvailable, p0);

    internal static string ParseError_IncompleteQuotesAroundDirective
        => @"Optional quote around the directive '{0}' is missing the corresponding opening or closing quote.";

    internal static string FormatParseError_IncompleteQuotesAroundDirective(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_IncompleteQuotesAroundDirective, p0);

    internal static string ParseError_InlineMarkup_Blocks_Cannot_Be_Nested
        => @"Inline markup blocks (@<p>Content</p>) cannot be nested.  Only one level of inline markup is allowed.";

    internal static string ParseError_MarkupBlock_Must_Start_With_Tag
        => @"Markup in a code block must start with a tag and all start tags must be matched with end tags.  Do not use unclosed tags like ""<br>"".  Instead use self-closing tags like ""<br/>"".";

    internal static string ParseError_MissingEndTag
        => @"The ""{0}"" element was not closed.  All elements must be either self-closing or have a matching end tag.";

    internal static string FormatParseError_MissingEndTag(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_MissingEndTag, p0);

    internal static string ParseError_NamespaceImportAndTypeAlias_Cannot_Exist_Within_CodeBlock
        => @"Namespace imports and type aliases cannot be placed within code blocks.  They must immediately follow an ""@"" character in markup.  It is recommended that you put them at the top of the page, as in the following example:

@using System.Drawing;
@{{
    // OK here to use types from System.Drawing in the page.
}}";

    internal static string ParseError_OuterTagMissingName
        => @"Outer tag is missing a name. The first character of a markup block must be an HTML tag with a valid name.";

    internal static string ParseError_RazorComment_Not_Terminated
        => @"End of file was reached before the end of the block comment.  All comments that start with the ""@*"" sequence must be terminated with a matching ""*@"" sequence.";

    internal static string ParseError_ReservedWord
        => @"""{0}"" is a reserved word and cannot be used in implicit expressions.  An explicit expression (""@()"") must be used.";

    internal static string FormatParseError_ReservedWord(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_ReservedWord, p0);

    internal static string ParseError_Sections_Cannot_Be_Nested
        => @"Section blocks (""{0}"") cannot be nested.  Only one level of section blocks are allowed.";

    internal static string FormatParseError_Sections_Cannot_Be_Nested(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_Sections_Cannot_Be_Nested, p0);

    internal static string ParseError_SingleLine_ControlFlowStatements_CannotContainMarkup
        => @"Single-statement control-flow statements in Razor documents statements cannot contain markup. Markup should be enclosed in ""{{"" and ""}}"".";

    internal static string ParseError_TextTagCannotContainAttributes
        => @"""<text>"" and ""</text>"" tags cannot contain attributes.";

    internal static string ParseError_Unexpected_Character_At_Start_Of_CodeBlock
        => @"""{0}"" is not valid at the start of a code block.  Only identifiers, keywords, comments, ""("" and ""{{"" are valid.";

    internal static string FormatParseError_Unexpected_Character_At_Start_Of_CodeBlock(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_Unexpected_Character_At_Start_Of_CodeBlock, p0);

    internal static string ParseError_Unexpected_EndOfFile_At_Start_Of_CodeBlock
        => @"End-of-file was found after the ""@"" character.  ""@"" must be followed by a valid code block.  If you want to output an ""@"", escape it using the sequence: ""@@""";

    internal static string ParseError_Unexpected_Nested_CodeBlock
        => @"Unexpected ""{{"" after ""@"" character. Once inside the body of a code block (@if {{}}, @{{}}, etc.) you do not need to use ""@{{"" to switch to code.";

    internal static string ParseError_Unexpected_WhiteSpace_At_Start_Of_CodeBlock
        => @"A space or line break was encountered after the ""@"" character.  Only valid identifiers, keywords, comments, ""("" and ""{{"" are valid at the start of a code block and they must occur immediately following ""@"" with no space in between.";

    internal static string ParseError_UnexpectedEndTag
        => @"Encountered end tag ""{0}"" with no matching start tag.  Are your start/end tags properly balanced?";

    internal static string FormatParseError_UnexpectedEndTag(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_UnexpectedEndTag, p0);

    internal static string ParseError_UnfinishedTag
        => @"End of file or an unexpected character was reached before the ""{0}"" tag could be parsed.  Elements inside markup blocks must be complete. They must either be self-closing (""<br />"") or have matching end tags (""<p>Hello</p>"").  If you intended to display a ""<"" character, use the ""&lt;"" HTML entity.";

    internal static string FormatParseError_UnfinishedTag(object p0)
        => string.Format(CultureInfo.InvariantCulture, ParseError_UnfinishedTag, p0);

    internal static string ParseError_Unterminated_String_Literal
        => @"Unterminated string literal.  Strings that start with a quotation mark ("") must be terminated before the end of the line.  However, strings that start with @ and a quotation mark (@"") can span multiple lines.";

    internal static string Parser_Context_Not_Set
        => @"Parser was started with a null Context property.  The Context property must be set BEFORE calling any methods on the parser.";

    internal static string ParserContext_CannotCompleteTree_NoRootBlock
        => @"Cannot complete the tree, StartBlock must be called at least once.";

    internal static string ParserContext_CannotCompleteTree_OutstandingBlocks
        => @"Cannot complete the tree, there are still open blocks.";

    internal static string ParserContext_NoCurrentBlock
        => @"Cannot finish span, there is no current block. Call StartBlock at least once before finishing a span";

    internal static string PhaseDependencyMissing
        => @"The '{0}' phase requires a '{1}' provided by the '{2}'.";

    internal static string FormatPhaseDependencyMissing(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, PhaseDependencyMissing, p0, p1, p2);

    internal static string PhaseMustBeInitialized
        => @"The phase must be initialized by setting the '{0}' property.";

    internal static string FormatPhaseMustBeInitialized(object p0)
        => string.Format(CultureInfo.InvariantCulture, PhaseMustBeInitialized, p0);

    internal static string RazorProject_PathMustStartWithForwardSlash
        => @"Path must begin with a forward slash '/'.";

    internal static string RemoveTagHelperDirective_Description
        => @"Remove Tag Helpers for use in the current document.";

    internal static string RemoveTagHelperDirective_StringToken_Description
        => @"Remove tag helpers from the specified type name and assembly name. Specify '*' for the type name to remove all tag helper types from the specified assembly.";

    internal static string RemoveTagHelperDirective_StringToken_Name
        => @"TypeName, AssemblyName";

    internal static string RenderingContextRequiresDelegate
        => @"The '{0}' requires a '{1}' delegate to be set.";

    internal static string FormatRenderingContextRequiresDelegate(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, RenderingContextRequiresDelegate, p0, p1);

    internal static string RewriterError_EmptyTagHelperBoundAttribute
        => @"Attribute '{0}' on tag helper element '{1}' requires a value. Tag helper bound attributes of type '{2}' cannot be empty or contain only whitespace.";

    internal static string FormatRewriterError_EmptyTagHelperBoundAttribute(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, RewriterError_EmptyTagHelperBoundAttribute, p0, p1, p2);

    internal static string SectionDirective_Description
        => @"Define a section to be rendered in the configured layout page.";

    internal static string SectionDirective_NameToken_Description
        => @"The name of the section.";

    internal static string SectionDirective_NameToken_Name
        => @"SectionName";

    internal static string SectionExample
        => @"@section Header { ... }";

    internal static string Token_Unknown
        => @"<<unknown>>";

    internal static string TagHelper_InvalidBoundAttributeName
        => @"Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with name '{2}' because the name contains a '{3}' character.";

    internal static string FormatTagHelper_InvalidBoundAttributeName(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributeName, p0, p1, p2, p3);

    internal static string TagHelper_InvalidBoundAttributeNameStartsWith
        => @"Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with name '{2}' because the name starts with '{3}'.";

    internal static string FormatTagHelper_InvalidBoundAttributeNameStartsWith(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributeNameStartsWith, p0, p1, p2, p3);

    internal static string TagHelper_InvalidBoundAttributeNullOrWhitespace
        => @"Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with a null or empty name.";

    internal static string FormatTagHelper_InvalidBoundAttributeNullOrWhitespace(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributeNullOrWhitespace, p0, p1);

    internal static string TagHelper_InvalidBoundAttributePrefix
        => @"Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with prefix '{2}' because the prefix contains a '{3}' character.";

    internal static string FormatTagHelper_InvalidBoundAttributePrefix(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributePrefix, p0, p1, p2, p3);

    internal static string TagHelper_InvalidBoundAttributePrefixStartsWith
        => @"Invalid tag helper bound property '{1}' on tag helper '{0}'. Tag helpers cannot bind to HTML attributes with prefix '{2}' because the prefix starts with '{3}'.";

    internal static string FormatTagHelper_InvalidBoundAttributePrefixStartsWith(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributePrefixStartsWith, p0, p1, p2, p3);

    internal static string TagHelper_InvalidRestrictedChild
        => @"Invalid restricted child '{1}' for tag helper '{0}'. Tag helpers cannot restrict child elements that contain a '{2}' character.";

    internal static string FormatTagHelper_InvalidRestrictedChild(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidRestrictedChild, p0, p1, p2);

    internal static string TagHelper_InvalidRestrictedChildNullOrWhitespace
        => @"Invalid restricted child for tag helper '{0}'. Name cannot be null or whitespace.";

    internal static string FormatTagHelper_InvalidRestrictedChildNullOrWhitespace(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidRestrictedChildNullOrWhitespace, p0);

    internal static string TagHelper_InvalidTargetedAttributeName
        => @"Tag helpers cannot target attribute name '{0}' because it contains a '{1}' character.";

    internal static string FormatTagHelper_InvalidTargetedAttributeName(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidTargetedAttributeName, p0, p1);

    internal static string TagHelper_InvalidTargetedAttributeNameNullOrWhitespace
        => @"Targeted attribute name cannot be null or whitespace.";

    internal static string TagHelper_InvalidTargetedParentTagName
        => @"Tag helpers cannot target parent tag name '{0}' because it contains a '{1}' character.";

    internal static string FormatTagHelper_InvalidTargetedParentTagName(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidTargetedParentTagName, p0, p1);

    internal static string TagHelper_InvalidTargetedParentTagNameNullOrWhitespace
        => @"Targeted parent tag name cannot be null or whitespace.";

    internal static string TagHelper_InvalidTargetedTagName
        => @"Tag helpers cannot target tag name '{0}' because it contains a '{1}' character.";

    internal static string FormatTagHelper_InvalidTargetedTagName(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidTargetedTagName, p0, p1);

    internal static string TagHelper_InvalidTargetedTagNameNullOrWhitespace
        => @"Targeted tag name cannot be null or whitespace.";

    internal static string TagHelperAssemblyNameCannotBeEmptyOrNull
        => @"Tag helper directive assembly name cannot be null or empty.";

    internal static string TagHelperBlockRewriter_IndexerAttributeNameMustIncludeKey
        => @"The tag helper attribute '{0}' in element '{1}' is missing a key. The syntax is '<{1} {0}{{ key }}=""value"">'.";

    internal static string FormatTagHelperBlockRewriter_IndexerAttributeNameMustIncludeKey(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelperBlockRewriter_IndexerAttributeNameMustIncludeKey, p0, p1);

    internal static string TagHelperBlockRewriter_TagHelperAttributeListMustBeWellFormed
        => @"TagHelper attributes must be well-formed.";

    internal static string TagHelperParseTreeRewriter_CannotHaveNonTagContent
        => @"The parent <{0}> tag helper does not allow non-tag content. Only child tag helper(s) targeting tag name(s) '{1}' are allowed.";

    internal static string FormatTagHelperParseTreeRewriter_CannotHaveNonTagContent(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelperParseTreeRewriter_CannotHaveNonTagContent, p0, p1);

    internal static string TagHelperParseTreeRewriter_EndTagTagHelperMustNotHaveAnEndTag
        => @"Found an end tag (</{0}>) for tag helper '{1}' with tag structure that disallows an end tag ('{2}').";

    internal static string FormatTagHelperParseTreeRewriter_EndTagTagHelperMustNotHaveAnEndTag(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, TagHelperParseTreeRewriter_EndTagTagHelperMustNotHaveAnEndTag, p0, p1, p2);

    internal static string TagHelperParseTreeRewriter_InconsistentTagStructure
        => @"Tag helpers '{0}' and '{1}' targeting element '{2}' must not expect different {3} values.";

    internal static string FormatTagHelperParseTreeRewriter_InconsistentTagStructure(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, TagHelperParseTreeRewriter_InconsistentTagStructure, p0, p1, p2, p3);

    internal static string TagHelperParseTreeRewriter_InvalidNestedTag
        => @"The <{0}> tag is not allowed by parent <{1}> tag helper. Only child tags with name(s) '{2}' are allowed.";

    internal static string FormatTagHelperParseTreeRewriter_InvalidNestedTag(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, TagHelperParseTreeRewriter_InvalidNestedTag, p0, p1, p2);

    internal static string TagHelperPrefixDirective_Description
        => @"Specify a prefix that is required in an element name for it to be included in Tag Helper processing.";

    internal static string TagHelperPrefixDirective_PrefixToken_Description
        => @"The tag prefix to apply to tag helpers.";

    internal static string TagHelperPrefixDirective_PrefixToken_Name
        => @"Prefix";

    internal static string TagHelpers_AttributesMustHaveAName
        => @"Tag Helper '{0}'s attributes must have names.";

    internal static string FormatTagHelpers_AttributesMustHaveAName(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelpers_AttributesMustHaveAName, p0);

    internal static string TagHelpers_CannotHaveCSharpInTagDeclaration
        => @"The tag helper '{0}' must not have C# in the element's attribute declaration area.";

    internal static string FormatTagHelpers_CannotHaveCSharpInTagDeclaration(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelpers_CannotHaveCSharpInTagDeclaration, p0);

    internal static string TagHelpers_CodeBlocks_NotSupported_InAttributes
        => @"Code blocks (e.g. @{{var variable = 23;}}) must not appear in non-string tag helper attribute values.
 Already in an expression (code) context. If necessary an explicit expression (e.g. @(@readonly)) may be used.";

    internal static string TagHelpers_InlineMarkupBlocks_NotSupported_InAttributes
        => @"Inline markup blocks (e.g. @<p>content</p>) must not appear in non-string tag helper attribute values.
 Expected a '{0}' attribute value, not a string.";

    internal static string FormatTagHelpers_InlineMarkupBlocks_NotSupported_InAttributes(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelpers_InlineMarkupBlocks_NotSupported_InAttributes, p0);

    internal static string TagHelpersParseTreeRewriter_FoundMalformedTagHelper
        => @"Found a malformed '{0}' tag helper. Tag helpers must have a start and end tag or be self closing.";

    internal static string FormatTagHelpersParseTreeRewriter_FoundMalformedTagHelper(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelpersParseTreeRewriter_FoundMalformedTagHelper, p0);

    internal static string TagHelpersParseTreeRewriter_MissingCloseAngle
        => @"Missing close angle for tag helper '{0}'.";

    internal static string FormatTagHelpersParseTreeRewriter_MissingCloseAngle(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelpersParseTreeRewriter_MissingCloseAngle, p0);

    internal static string UnexpectedDirectiveKind
        => @"Unreachable code. This can happen when a new {0} is introduced.";

    internal static string FormatUnexpectedDirectiveKind(object p0)
        => string.Format(CultureInfo.InvariantCulture, UnexpectedDirectiveKind, p0);

    internal static string UnexpectedDirectiveLiteral
        => @"Unexpected literal following the '{0}' directive. Expected '{1}'.";

    internal static string FormatUnexpectedDirectiveLiteral(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, UnexpectedDirectiveLiteral, p0, p1);

    internal static string UnexpectedEOFAfterDirective
        => @"Unexpected end of file following the '{0}' directive. Expected '{1}'.";

    internal static string FormatUnexpectedEOFAfterDirective(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, UnexpectedEOFAfterDirective, p0, p1);

    internal static string UnsupportedChecksumAlgorithm
        => @"The hash algorithm '{0}' is not supported for checksum generation. Supported algorithms are: '{1}'. Set '{2}' to '{3}' to suppress automatic checksum generation.";

    internal static string FormatUnsupportedChecksumAlgorithm(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, UnsupportedChecksumAlgorithm, p0, p1, p2, p3);

    internal static string PropertyMustNotBeNull
        => @"The '{0}.{1}' property must not be null.";

    internal static string FormatPropertyMustNotBeNull(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, PropertyMustNotBeNull, p0, p1);

    internal static string RazorProjectEngineMissingFeatureDependency
        => @"The '{0}' is missing feature '{1}'.";

    internal static string FormatRazorProjectEngineMissingFeatureDependency(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, RazorProjectEngineMissingFeatureDependency, p0, p1);

    internal static string RazorLanguageVersion_InvalidVersion
        => @"The Razor language version '{0}' is unrecognized or not supported by this version of Razor.";

    internal static string FormatRazorLanguageVersion_InvalidVersion(object p0)
        => string.Format(CultureInfo.InvariantCulture, RazorLanguageVersion_InvalidVersion, p0);

    internal static string VirtualFileSystem_FileDoesNotBelongToDirectory
        => @"File path '{0}' does not belong to the directory '{1}'.";

    internal static string FormatVirtualFileSystem_FileDoesNotBelongToDirectory(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, VirtualFileSystem_FileDoesNotBelongToDirectory, p0, p1);

    internal static string VirtualFileSystem_InvalidRelativePath
        => @"The file path '{0}' is invalid. File path is the root relative path of the file starting with '/' and should not contain any '\' characters.";

    internal static string FormatVirtualFileSystem_InvalidRelativePath(object p0)
        => string.Format(CultureInfo.InvariantCulture, VirtualFileSystem_InvalidRelativePath, p0);

    internal static string Rewriter_InsufficientStack
        => @"Not enough stack space to continue parsing this document. Razor doesn't support deeply nested elements.";

    internal static string NamespaceDirective_Description
        => @"Specify the base namespace for the document.";

    internal static string NamespaceDirective_NamespaceToken_Description
        => @"The namespace for the document.";

    internal static string NamespaceDirective_NamespaceToken_Name
        => @"Namespace";

    internal static string TagHelper_InvalidBoundAttributeParameterName
        => @"Invalid tag helper bound attribute parameter '{1}' on bound attribute '{0}'. Tag helpers cannot bind to HTML attribute parameters with name '{1}' because the name contains a '{3}' character.";

    internal static string FormatTagHelper_InvalidBoundAttributeParameterName(object p0, object p1, object p2, object p3)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributeParameterName, p0, p1, p2, p3);

    internal static string TagHelper_InvalidBoundAttributeParameterNullOrWhitespace
        => @"Invalid tag helper bound attribute parameter '{0}'. Tag helpers cannot bind to HTML attribute parameters with a null or empty name.";

    internal static string FormatTagHelper_InvalidBoundAttributeParameterNullOrWhitespace(object p0)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundAttributeParameterNullOrWhitespace, p0);

    internal static string DirectiveExpectsCSharpAttribute
        => @"The '{0}' directive expects a C# attribute.";

    internal static string FormatDirectiveExpectsCSharpAttribute(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveExpectsCSharpAttribute, p0);

    internal static string TagHelper_InvalidBoundDirectiveAttributeName
        => @"Invalid tag helper bound directive attribute '{1}' on tag helper '{0}'. The directive attribute '{2}' should start with a '@' character.";

    internal static string FormatTagHelper_InvalidBoundDirectiveAttributeName(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundDirectiveAttributeName, p0, p1, p2);

    internal static string TagHelper_InvalidBoundDirectiveAttributePrefix
        => @"Invalid tag helper bound directive attribute '{1}' on tag helper '{0}'. Tag helpers cannot bind to directive attributes with prefix '{2}' because the prefix doesn't start with a '@' character.";

    internal static string FormatTagHelper_InvalidBoundDirectiveAttributePrefix(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidBoundDirectiveAttributePrefix, p0, p1, p2);

    internal static string TagHelper_InvalidRequiredDirectiveAttributeName
        => @"Invalid tag helper required directive attribute '{0}'. The directive attribute '{1}' should start with a '@' character.";

    internal static string FormatTagHelper_InvalidRequiredDirectiveAttributeName(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, TagHelper_InvalidRequiredDirectiveAttributeName, p0, p1);

    internal static string DirectiveExpectsBooleanLiteral
        => @"The '{0}' directive expects a boolean literal.";

    internal static string FormatDirectiveExpectsBooleanLiteral(object p0)
        => string.Format(CultureInfo.InvariantCulture, DirectiveExpectsBooleanLiteral, p0);

    internal static string CssRewriter_ImportNotAllowed
        => @"@import rules are not supported within scoped CSS files because the loading order would be undefined. @import may only be placed in non-scoped CSS files.";

    internal static string DirectiveGenericTypeParameterIdentifierMismatch
        => @"The type parameter in the generic type constraint '{1}' does not match the type parameter '{2}' defined in the directive '{0}'.";

    internal static string FormatDirectiveGenericTypeParameterIdentifierMismatch(object p0, object p1, object p2)
        => string.Format(CultureInfo.InvariantCulture, DirectiveGenericTypeParameterIdentifierMismatch, p0, p1, p2);

    internal static string ParseError_Unexpected_Identifier_At_Position
        => @"'{0}' is not valid in this position. Valid options are '{1}'";

    internal static string FormatParseError_Unexpected_Identifier_At_Position(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, ParseError_Unexpected_Identifier_At_Position, p0, p1);

    internal static string Component_EditorRequiredParameterNotSpecified
        => @"Component '{0}' expects a value for the parameter '{1}', but a value may not have been provided.";

    internal static string FormatComponent_EditorRequiredParameterNotSpecified(object p0, object p1)
        => string.Format(CultureInfo.InvariantCulture, Component_EditorRequiredParameterNotSpecified, p0, p1);

    internal static string RazorDiagnosticDescriptor_DefaultError
        => @"Encountered diagnostic '{0}'.";

    internal static string FormatRazorDiagnosticDescriptor_DefaultError(object p0)
        => string.Format(CultureInfo.InvariantCulture, RazorDiagnosticDescriptor_DefaultError, p0);

}

#endif
