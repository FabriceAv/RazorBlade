using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using RazorBlade.Analyzers.Support;
using RazorBlade.MetaAnalyzers.Support;

namespace RazorBlade.MetaAnalyzers;

[Generator]
public class EmbeddedLibrarySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var inputFiles = context.AdditionalTextsProvider
                                .Where(static i => i.Path.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))
                                .Combine(context.AnalyzerConfigOptionsProvider)
                                .Select(static (pair, _) => GetInputFile(pair.Left, pair.Right))
                                .WhereNotNull();

        var memberNames = inputFiles.Select(static (i, _) => i.GetMemberName())
                                    .Collect();

        context.RegisterImplementationSourceOutput(inputFiles, GenerateContent);
        context.RegisterSourceOutput(memberNames, GenerateSummary);
    }

    private static InputFile? GetInputFile(AdditionalText additionalText, AnalyzerConfigOptionsProvider analyzerConfigOptions)
    {
        var options = analyzerConfigOptions.GetOptions(additionalText);

        if (!options.TryGetValue("build_metadata.AdditionalFiles.Role", out var role) || !string.Equals(role, "Library", StringComparison.OrdinalIgnoreCase))
            return null;

        return new InputFile(additionalText);
    }

    private static void GenerateContent(SourceProductionContext context, InputFile inputFile)
    {
        var sourceText = inputFile.AdditionalText.GetText(context.CancellationToken);
        if (sourceText is null)
            return;

        var inputText = sourceText.ToString();
        var memberName = inputFile.GetMemberName();

        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            var escapeQuotes = GetRawStringLiteralQuotes(inputText);

            writer.WriteLine($"private static string {memberName} => /*language=csharp*/ {escapeQuotes}");
            var indent = writer.Indent;
            writer.Indent = 0;
            writer.WriteLine(inputText);
            writer.WriteLine($"{escapeQuotes};");
            writer.Indent = indent;
        }

        context.AddSource($"{memberName}.g.cs", writer.ToString());
    }

    private static void GenerateSummary(SourceProductionContext context, ImmutableArray<string> memberNames)
    {
        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            writer.WriteLine("public static readonly string[] SourceFiles = {");

            using (writer.IndentScope())
            {
                foreach (var memberName in memberNames.OrderBy(i => i, StringComparer.OrdinalIgnoreCase))
                    writer.WriteLine($"{memberName},");
            }

            writer.WriteLine("};");
        }

        context.AddSource("SourceFiles.g.cs", writer.ToString());
    }

    private static void WriteHeader(SourceWriter writer)
    {
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine();
        writer.WriteLine("using System.Globalization;");
        writer.WriteLine();
        writer.WriteLine("namespace RazorBlade.Analyzers;");
        writer.WriteLine();
        writer.WriteLine("internal static partial class EmbeddedLibrary");
    }

    private static string GetRawStringLiteralQuotes(string value)
    {
        var escapeQuotesLength = 3;
        foreach (Match match in Regex.Matches(value, @"""+"))
            escapeQuotesLength = Math.Max(escapeQuotesLength, match.Length + 1);

        return new string('"', escapeQuotesLength);
    }

    private record InputFile(AdditionalText AdditionalText)
    {
        public string GetMemberName()
            => Path.GetFileNameWithoutExtension(AdditionalText.Path);
    }
}
