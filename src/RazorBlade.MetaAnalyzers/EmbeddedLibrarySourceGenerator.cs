using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using RazorBlade.Analyzers.Support;
using RazorBlade.MetaAnalyzers.Support;

namespace RazorBlade.MetaAnalyzers;

[Generator]
public class EmbeddedLibrarySourceGenerator : IIncrementalGenerator
{
    internal bool SkipSummary { get; init; }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var inputFiles = context.AdditionalTextsProvider
                                .Where(static i => i.Path.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))
                                .Combine(context.AnalyzerConfigOptionsProvider)
                                .Select(static (pair, _) => GetInputFile(pair.Left, pair.Right))
                                .WhereNotNull();

        var memberNames = inputFiles.Select(static (i, _) => i.GetMemberName())
                                    .Collect();

        context.RegisterImplementationSourceOutput(inputFiles, GenerateContent);

        if (!SkipSummary)
            context.RegisterSourceOutput(memberNames, GenerateSummary);
    }

    private static InputFile? GetInputFile(AdditionalText additionalText, AnalyzerConfigOptionsProvider analyzerConfigOptions)
    {
        var options = analyzerConfigOptions.GetOptions(additionalText);

        if (!options.TryGetValue("build_metadata.AdditionalFiles.Role", out var role) || !string.Equals(role, "Library", StringComparison.OrdinalIgnoreCase))
            return null;

        return new InputFile(additionalText);
    }

    private static void GenerateContent(SourceProductionContext context, InputFile inputFile)
    {
        var sourceText = inputFile.AdditionalText.GetText(context.CancellationToken);
        if (sourceText is null)
            return;

        var inputText = TransformSource(sourceText, context.CancellationToken);
        var memberName = inputFile.GetMemberName();

        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            var escapeQuotes = GetRawStringLiteralQuotes(inputText);

            writer.WriteLine($"private static string {memberName} => /*language=csharp*/ {escapeQuotes}");
            var indent = writer.Indent;
            writer.Indent = 0;
            writer.WriteLine(inputText);
            writer.WriteLine($"{escapeQuotes};");
            writer.Indent = indent;
        }

        context.AddSource($"{memberName}.g.cs", writer.ToString());
    }

    private static void GenerateSummary(SourceProductionContext context, ImmutableArray<string> memberNames)
    {
        var writer = new SourceWriter();
        WriteHeader(writer);

        using (writer.BlockScope())
        {
            writer.WriteLine("public static readonly string[] SourceFiles = {");

            using (writer.IndentScope())
            {
                foreach (var memberName in memberNames.OrderBy(i => i, StringComparer.OrdinalIgnoreCase))
                    writer.WriteLine($"{memberName},");
            }

            writer.WriteLine("};");
        }

        context.AddSource("SourceFiles.g.cs", writer.ToString());
    }

    private static void WriteHeader(SourceWriter writer)
    {
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine();
        writer.WriteLine("namespace RazorBlade.Analyzers;");
        writer.WriteLine();
        writer.WriteLine("internal static partial class EmbeddedLibrary");
    }

    private static string TransformSource(SourceText sourceText, CancellationToken cancellationToken)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(sourceText, CSharpParseOptions.Default, cancellationToken: cancellationToken);
        var root = syntaxTree.GetRoot(cancellationToken);

        // - Add header comment
        // - Add #nullable enable
        // - Make public top-level types internal
        // - Remove JetBrains annotations
        // - Replace file-scoped namespaces with block-scoped ones

        root = new TopLevelTypesVisibilityRewriter().Rewrite(root);

        return root.ToFullString();
    }

    private static string GetRawStringLiteralQuotes(string value)
    {
        var escapeQuotesLength = 3;
        foreach (Match match in Regex.Matches(value, @"""+"))
            escapeQuotesLength = Math.Max(escapeQuotesLength, match.Length + 1);

        return new string('"', escapeQuotesLength);
    }

    private record InputFile(AdditionalText AdditionalText)
    {
        public string GetMemberName()
            => Path.GetFileNameWithoutExtension(AdditionalText.Path);
    }

    private class TopLevelTypesVisibilityRewriter : CSharpSyntaxWalker
    {
        private readonly List<SyntaxToken> _toReplace = new();

        public SyntaxNode Rewrite(SyntaxNode root)
        {
            _toReplace.Clear();
            Visit(root);

            return root.ReplaceTokens(
                _toReplace,
                static (token, _) => SyntaxFactory.Token(SyntaxKind.InternalKeyword)
                                                  .WithTriviaFrom(token)
            );
        }

        public override void DefaultVisit(SyntaxNode node)
        {
            if (node is BaseTypeDeclarationSyntax type)
            {
                HandleTopLevelMember(type);
                return;
            }

            base.DefaultVisit(node);
        }

        public override void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
            => HandleTopLevelMember(node);

        private void HandleTopLevelMember(MemberDeclarationSyntax node)
        {
            foreach (var modifier in node.Modifiers)
            {
                if (modifier.IsKind(SyntaxKind.PublicKeyword))
                    _toReplace.Add(modifier);
            }
        }
    }
}
